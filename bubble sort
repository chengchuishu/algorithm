以从小到大排序为例，冒泡排序的整体思想是这样的：
 从数组头部开始，不断比较相邻的两个元素的大小，让较大的元素逐渐往后移动（交换两个元素的值），直到数组的末尾。经过第一轮的比较，就可以找到最大的元素，并将它移动到最后一个位置。
 第一轮结束后，继续第二轮。仍然从数组头部开始比较，让较大的元素逐渐往后移动，直到数组的倒数第二个元素为止。经过第二轮的比较，就可以找到次大的元素，并将它放到倒数第二个位置。
 以此类推，进行 n-1（n 为数组长度）轮“冒泡”后，就可以将所有的元素都排列好。
整个排序过程就好像气泡不断从水里冒出来，最大的先出来，次大的第二出来，最小的最后出来，所以将这种排序方式称为冒泡排序（Bubble Sort）。

优化算法
上面的算法是大部分教材中提供的算法，其中有一点是可以优化的：当比较到第 i 轮的时候，如果剩下的元素已经
排序好了，那么就不用再继续比较了，跳出循环即可，这样就减少了比较的次数，提高了执行效率。
未经优化的算法一定会进行 n-1 轮比较，经过优化的算法最多进行 n-1 轮比较，高下立判。
优化后的算法实现如下所示：
#include <stdio.h>
int main() {
  int nums[10] = { 4, 5, 2, 10, 7, 1, 8, 3, 6, 9 };
  int i, j, temp, isSorted;
  //优化算法：最多进行 n-1 轮比较
  for (i = 0; i<10 - 1; i++) {
    isSorted = 1; //假设剩下的元素已经排序好了
    for (j = 0; j<10 - 1 - i; j++) {
      if (nums[j] > nums[j + 1]) {
        temp = nums[j];
        nums[j] = nums[j + 1];
        nums[j + 1] = temp;
        isSorted = 0; //一旦需要交换数组元素，就说明剩下的元素没有排序好
      }
    }
    if (isSorted) break; //如果没有发生交换，说明剩下的元素已经排序好了
  }
  for (i = 0; i<10; i++) {
    printf("%d ", nums[i]);
  }
  printf("\n");
  return 0;
}
我们额外设置了一个变量 isSorted，用它作为标志，值为“真”表示剩下的元素已经排序好了，值为“假”表示剩
下的元素还未排序好。
每一轮比较之前，我们预先假设剩下的元素已经排序好了，并将 isSorted 设置为“真”，一旦在比较过程中需要交
换元素，就说明假设是错的，剩下的元素没有排序好，于是将 isSorted 的值更改为“假”。
每一轮循环结束后，通过检测 isSorted 的值就知道剩下的元素是否排序好。
